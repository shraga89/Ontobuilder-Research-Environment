/**
 * 
 */
package Application;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;

import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;

import com.modica.ontology.Ontology;
import com.modica.ontology.Term;
import com.modica.ontology.match.MatchInformation;

import schemamatchings.meta.match.MatchedAttributePair;
import schemamatchings.ontobuilder.MatchingAlgorithms;
import schemamatchings.ontobuilder.OntoBuilderWrapper;
import schemamatchings.ontobuilder.OntoBuilderWrapperException;
import schemamatchings.util.BestMappingsWrapper;
import schemamatchings.util.MappingAlgorithms;
import schemamatchings.util.SchemaTranslator;
import smb_service.Schema;


/**
 * Class Includes tools for matching concepts with schemas
 * Uses ontobuilder as a matching system to perform matching
 * 
 * @author Tomer Sagi 
 * 
 *
 */
public class NisBConceptMatcher 
{
	
	/**
	 * Class constructor
	 * @param schemaID ID of the schema to be matched to the concepts
	 * @param schemaName Name of the above mentioned schema
	 * @param terms HashMap<termID, termName> of the terms in the above mentioned schema
	 * @param termAmbiguity
	 * @param Ontology o Ontology object of the schema to be used in the matching
	 */
	//TODO add printers for all required interfaces from Michael
	public NisBConceptMatcher(long schemaID, String schemaName, Ontology o,HashMap<Long, String> terms
			,HashMap<Long, Integer> termAmbiguity) 
	{
		this.schema = new Schema(schemaID, schemaName,new HashMap<String, Long>(), terms);
		this.ontology = o;
		this.termAmbiguity = termAmbiguity;
		concepts = new ArrayList<Concept>();
		subSchemata = new ArrayList<Schema>();
	}

	ArrayList<Concept> concepts;
	Schema schema;
	Ontology ontology;
	HashMap<Long,Integer> termAmbiguity;
	ArrayList<Schema> subSchemata;
	
	/**
	 * Matches the schema with the concepts and generates a confidence value
	 * between each concept and subschema
	 * @return tab delimited string of subSchemaId ConceptId coverConfidence
	 */
	public ArrayList<String[]> generateCoverOptions()
	{
		ArrayList<String[]> res = new ArrayList<String[]>();
		
		//TODO for each concept - match and generate a sub schema with it's cover confidence
		for (int i = 0;i<concepts.size();i++)
		{
			//Match concept and ontology using term and MWBG
			MatchedAttributePair[] mp = mapConcept(concepts.get(i));
			//Create sub-schema from mapped items
			HashMap<Long,String> terms = new HashMap<Long,String>();
			for (int j=0;j<mp.length;j++) terms.put(mp[j].id2,schema.terms.get(mp[j].id2));
			//TODO replace i as schemaId with an id generated by combination of k and i
			Schema subSchema = new Schema(i, terms.toString(),null, terms);
			
			//if new, add subschema to list of subschemas 
			//TODO if new...
			subSchemata.add(new Schema());
			
			//generate confidence and add to result
			DescriptiveStatistics DS = new DescriptiveStatistics();
			for (int j=0;j<mp.length;j++) DS.addValue(mp[j].getMatchedPairWeight());
			double confidence = (DS.getN()>0 ? DS.getMean() : 0);
			String strRes[] = {Long.toString(concepts.get(i).id),subSchema.schemaName,Double.toString(confidence)}; 
			res.add(strRes);
		}
		return res;
	}
	
	public void addConcept(long id, String name, HashMap<Long,String> terms )
	{
		concepts.add(new Concept(id,name,terms));
	}
	
	private MatchedAttributePair[] mapConcept(Concept c)
	{
		//TODO add top k subschemas and return an array list of schema translators
		MatchedAttributePair[] mp = null;
		OntoBuilderWrapper obw = new OntoBuilderWrapper();
		try {
			//Generate match matrix using TERM
			MatchInformation mi = obw.matchOntologies(ontology, c.toOntology(), MatchingAlgorithms.TERM);
			//Generate mapping using MWBG from match matrix generated by term
			BestMappingsWrapper.matchMatrix = mi.getMatrix();
	        SchemaTranslator st = BestMappingsWrapper.GetBestMapping(MappingAlgorithms.MAX_WEIGHT_BIPARTITE_GRAPH);
			st.importIdsFromMatchInfo(mi,true);
			mp = st.getMatchedPairs();
		
		} catch (OntoBuilderWrapperException e) 
		{
			e.printStackTrace();
		}
		return mp;
	}
	
	private class Concept
	{
		public Concept(long id, String name) {
			this.id = id;
			this.name = name;
			terms = new HashMap<Long,String>() ;
			
		}
		public Concept(long id2, String name2, HashMap<Long, String> terms2) 
		{
			this(id2,name2);
			this.terms = terms2;

		}
		public Ontology toOntology() 
		{
			Ontology o = new Ontology(name);
			Iterator<Long> it = terms.keySet().iterator();
			while (it.hasNext())
			{
				Long termId = it.next();
				String termName = terms.get(termId);
				o.addTerm(new Term(termId.toString(), termName , termName ));
			}
			return o;
		}
		
		@SuppressWarnings("unused")
		public void addTerm(long termId,String termName) 
		{
			terms.put(termId, termName);
		}
		
		public long id;
		public String name;
		public HashMap<Long,String> terms;
	}

}
